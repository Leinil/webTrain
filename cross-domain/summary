# 关于我们经常遇到的跨域问题

## 一、同源策略

+ 浏览器的同源策略：保证用户安全、防止恶意的网站盗取数据、禁止不同域下的js交互

+ 同源策略中同源是指：协议、域名、端口号相同 

## 二、CORS：跨域资源共享

### 2.1、请求分类

CORS需要浏览器和服务器同时支持，目前浏览器已经都已经支持了该功能，只要服务器实现了CORS接口，就可以跨域通信了


对于浏览器而言CORS请求分为了简单请求和非简单请求。
1. 简单请求：（同时满足以下两大条件）
    
     (1) 满足请求方法是 HEAD、GET、POST之一
     
    (2) http的头信息不超过以下几种字段
    + Accept
    + Accept-Language
    + Content-Language
    + Last-Event-ID
    + Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain

只要不同时满足以上两个条件的都是飞简单请求，浏览器对于两种请求的处理 是不一样的。

### 2.1、简单请求

对于简单请求而言，浏览器直接发出CORS请求，只是在头信息中添加一个Origin字段，用来说明本次请求来自哪个源，服务器根据这个值来决定是否用以这次请求。如果服务器发现Origin不在许可范围内，那虽然会返回一个 ***正常的状态码***，但是 回应的消息头中不会包含Access-Control-Allow-Origin字段。这时浏览器就会抛出一个错误，开发者就知道出错了。需要注意的是，这种错误的状态码是200，所以不能通过状态码 来识别。

一些基本的返回头就是不说了，在这里提一点就是Access-Control-Allow-Credentials这个属性默认是不需要开启的，他是当需要传cookie给服务器的时候用的，如果要传这个给服务器的话，一方面是需要服务器开启它为True，另一方面的话在发送ajax请求的时候需要设置xhr.withCredentials=true。但是有点浏览器在不设置withCredentials的时候也会发送cookie，可以显示的设置他为false

### 2.2、非简单请求
非简单请求一般是需要对服务器的返回值有一定的特殊要求。put、delete或者是Content-Type字段的类型是application/json

对于非简单的CORS请求，在正式的通信之前会发送一次预请求（preflight）。预请求的作用就是在正式发送请求之前，浏览器先询问服务器当前页面所在的域名是否在服务器的许可名单之中，以及可以使用那些http动词和头信息字段。

**PS：刚刚在实验室，学到了一种控制首页loading效果的新方式，我们一般都是在window.onload （ready）的时候清除loadin效果。但是这种一般只适用于初始化页面加载时的效果处理，如果遇到一个loading 受多个异步js请求影响的时候，这种方式就会显得很麻烦。因为你如果为了去判断是否该去除loading展示的时候会造成同时牵扯几个不同的请求的现象，判断的话就会变得复杂。这时利用xmlhttprequest的beforeSend来开启loading，并在complete的时候关闭。这种处理就会显得方便一些。之前可能只在其他页面交互的时候想到这样做（但是好像都没用这种方法。。。。。），现在又多了一种思路。由于是涉及请求方面的知识，跟这篇文章沾一点边，所以直接在这个地方记录以下**

只有当浏览器得到了肯定答复之后才会正式发出请求，否则就报错。
与请求用的方式是“option”，一般都会有Origin字段和简单请求一样用来表示是哪一个源的
另外 Access-Control-Request-Method 也是必须的 用来表示CORS使用的是什么方法。Access-control-Request-Headers使用逗号来分割额外的请求头。

如果，服务器拒绝了浏览器的访问，和简单请求一样会返回一个正常的http响应。但是没有任何CORS相关的相应头信息，这时候浏览器就知道我们的请求拒绝了，就会触发一个错误。如果是一个被允许的请求的话，会在返回头中加上Access-Control-Max-Age（本次预请求的有效期，在有效期内该请求不用再次发送预请求）等字段

